// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_
#define FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace darknet7 {

struct GenericResponse;

struct Badges;

struct BadgesInArea;

struct ESPSystemInfo;

struct ESPToSTM;

enum RESPONSE_SUCCESS {
  RESPONSE_SUCCESS_False = 0,
  RESPONSE_SUCCESS_True = 1,
  RESPONSE_SUCCESS_MIN = RESPONSE_SUCCESS_False,
  RESPONSE_SUCCESS_MAX = RESPONSE_SUCCESS_True
};

inline const RESPONSE_SUCCESS (&EnumValuesRESPONSE_SUCCESS())[2] {
  static const RESPONSE_SUCCESS values[] = {
    RESPONSE_SUCCESS_False,
    RESPONSE_SUCCESS_True
  };
  return values;
}

inline const char * const *EnumNamesRESPONSE_SUCCESS() {
  static const char * const names[] = {
    "False",
    "True",
    nullptr
  };
  return names;
}

inline const char *EnumNameRESPONSE_SUCCESS(RESPONSE_SUCCESS e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRESPONSE_SUCCESS()[index];
}

enum ESPToSTMAny {
  ESPToSTMAny_NONE = 0,
  ESPToSTMAny_GenericResponse = 1,
  ESPToSTMAny_ESPSystemInfo = 2,
  ESPToSTMAny_MIN = ESPToSTMAny_NONE,
  ESPToSTMAny_MAX = ESPToSTMAny_ESPSystemInfo
};

inline const ESPToSTMAny (&EnumValuesESPToSTMAny())[3] {
  static const ESPToSTMAny values[] = {
    ESPToSTMAny_NONE,
    ESPToSTMAny_GenericResponse,
    ESPToSTMAny_ESPSystemInfo
  };
  return values;
}

inline const char * const *EnumNamesESPToSTMAny() {
  static const char * const names[] = {
    "NONE",
    "GenericResponse",
    "ESPSystemInfo",
    nullptr
  };
  return names;
}

inline const char *EnumNameESPToSTMAny(ESPToSTMAny e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesESPToSTMAny()[index];
}

template<typename T> struct ESPToSTMAnyTraits {
  static const ESPToSTMAny enum_value = ESPToSTMAny_NONE;
};

template<> struct ESPToSTMAnyTraits<GenericResponse> {
  static const ESPToSTMAny enum_value = ESPToSTMAny_GenericResponse;
};

template<> struct ESPToSTMAnyTraits<ESPSystemInfo> {
  static const ESPToSTMAny enum_value = ESPToSTMAny_ESPSystemInfo;
};

bool VerifyESPToSTMAny(flatbuffers::Verifier &verifier, const void *obj, ESPToSTMAny type);
bool VerifyESPToSTMAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GenericResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESSFUL = 4,
    VT_MESSAGE = 6
  };
  RESPONSE_SUCCESS successful() const {
    return static_cast<RESPONSE_SUCCESS>(GetField<int8_t>(VT_SUCCESSFUL, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SUCCESSFUL) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct GenericResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_successful(RESPONSE_SUCCESS successful) {
    fbb_.AddElement<int8_t>(GenericResponse::VT_SUCCESSFUL, static_cast<int8_t>(successful), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(GenericResponse::VT_MESSAGE, message);
  }
  explicit GenericResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GenericResponseBuilder &operator=(const GenericResponseBuilder &);
  flatbuffers::Offset<GenericResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GenericResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GenericResponse> CreateGenericResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    RESPONSE_SUCCESS successful = RESPONSE_SUCCESS_False,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  GenericResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_successful(successful);
  return builder_.Finish();
}

inline flatbuffers::Offset<GenericResponse> CreateGenericResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RESPONSE_SUCCESS successful = RESPONSE_SUCCESS_False,
    const char *message = nullptr) {
  return darknet7::CreateGenericResponse(
      _fbb,
      successful,
      message ? _fbb.CreateString(message) : 0);
}

struct Badges FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_NAMES = 6
  };
  const flatbuffers::Vector<uint8_t> *Address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  const flatbuffers::String *Names() const {
    return GetPointer<const flatbuffers::String *>(VT_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(Address()) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.Verify(Names()) &&
           verifier.EndTable();
  }
};

struct BadgesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Address) {
    fbb_.AddOffset(Badges::VT_ADDRESS, Address);
  }
  void add_Names(flatbuffers::Offset<flatbuffers::String> Names) {
    fbb_.AddOffset(Badges::VT_NAMES, Names);
  }
  explicit BadgesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BadgesBuilder &operator=(const BadgesBuilder &);
  flatbuffers::Offset<Badges> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Badges>(end);
    return o;
  }
};

inline flatbuffers::Offset<Badges> CreateBadges(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Address = 0,
    flatbuffers::Offset<flatbuffers::String> Names = 0) {
  BadgesBuilder builder_(_fbb);
  builder_.add_Names(Names);
  builder_.add_Address(Address);
  return builder_.Finish();
}

inline flatbuffers::Offset<Badges> CreateBadgesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *Address = nullptr,
    const char *Names = nullptr) {
  return darknet7::CreateBadges(
      _fbb,
      Address ? _fbb.CreateVector<uint8_t>(*Address) : 0,
      Names ? _fbb.CreateString(Names) : 0);
}

struct BadgesInArea FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BADGELIST = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Badges>> *BadgeList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Badges>> *>(VT_BADGELIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BADGELIST) &&
           verifier.Verify(BadgeList()) &&
           verifier.VerifyVectorOfTables(BadgeList()) &&
           verifier.EndTable();
  }
};

struct BadgesInAreaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_BadgeList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Badges>>> BadgeList) {
    fbb_.AddOffset(BadgesInArea::VT_BADGELIST, BadgeList);
  }
  explicit BadgesInAreaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BadgesInAreaBuilder &operator=(const BadgesInAreaBuilder &);
  flatbuffers::Offset<BadgesInArea> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BadgesInArea>(end);
    return o;
  }
};

inline flatbuffers::Offset<BadgesInArea> CreateBadgesInArea(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Badges>>> BadgeList = 0) {
  BadgesInAreaBuilder builder_(_fbb);
  builder_.add_BadgeList(BadgeList);
  return builder_.Finish();
}

inline flatbuffers::Offset<BadgesInArea> CreateBadgesInAreaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Badges>> *BadgeList = nullptr) {
  return darknet7::CreateBadgesInArea(
      _fbb,
      BadgeList ? _fbb.CreateVector<flatbuffers::Offset<Badges>>(*BadgeList) : 0);
}

struct ESPSystemInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEAPSIZE = 4,
    VT_MODEL = 6,
    VT_CORES = 8,
    VT_REVISION = 10,
    VT_FEATURES = 12,
    VT_IDF_VERSION = 14
  };
  uint32_t heapSize() const {
    return GetField<uint32_t>(VT_HEAPSIZE, 0);
  }
  int32_t model() const {
    return GetField<int32_t>(VT_MODEL, 0);
  }
  int32_t cores() const {
    return GetField<int32_t>(VT_CORES, 0);
  }
  int32_t revision() const {
    return GetField<int32_t>(VT_REVISION, 0);
  }
  int32_t features() const {
    return GetField<int32_t>(VT_FEATURES, 0);
  }
  const flatbuffers::String *idf_version() const {
    return GetPointer<const flatbuffers::String *>(VT_IDF_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HEAPSIZE) &&
           VerifyField<int32_t>(verifier, VT_MODEL) &&
           VerifyField<int32_t>(verifier, VT_CORES) &&
           VerifyField<int32_t>(verifier, VT_REVISION) &&
           VerifyField<int32_t>(verifier, VT_FEATURES) &&
           VerifyOffset(verifier, VT_IDF_VERSION) &&
           verifier.Verify(idf_version()) &&
           verifier.EndTable();
  }
};

struct ESPSystemInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heapSize(uint32_t heapSize) {
    fbb_.AddElement<uint32_t>(ESPSystemInfo::VT_HEAPSIZE, heapSize, 0);
  }
  void add_model(int32_t model) {
    fbb_.AddElement<int32_t>(ESPSystemInfo::VT_MODEL, model, 0);
  }
  void add_cores(int32_t cores) {
    fbb_.AddElement<int32_t>(ESPSystemInfo::VT_CORES, cores, 0);
  }
  void add_revision(int32_t revision) {
    fbb_.AddElement<int32_t>(ESPSystemInfo::VT_REVISION, revision, 0);
  }
  void add_features(int32_t features) {
    fbb_.AddElement<int32_t>(ESPSystemInfo::VT_FEATURES, features, 0);
  }
  void add_idf_version(flatbuffers::Offset<flatbuffers::String> idf_version) {
    fbb_.AddOffset(ESPSystemInfo::VT_IDF_VERSION, idf_version);
  }
  explicit ESPSystemInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ESPSystemInfoBuilder &operator=(const ESPSystemInfoBuilder &);
  flatbuffers::Offset<ESPSystemInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ESPSystemInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ESPSystemInfo> CreateESPSystemInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t heapSize = 0,
    int32_t model = 0,
    int32_t cores = 0,
    int32_t revision = 0,
    int32_t features = 0,
    flatbuffers::Offset<flatbuffers::String> idf_version = 0) {
  ESPSystemInfoBuilder builder_(_fbb);
  builder_.add_idf_version(idf_version);
  builder_.add_features(features);
  builder_.add_revision(revision);
  builder_.add_cores(cores);
  builder_.add_model(model);
  builder_.add_heapSize(heapSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<ESPSystemInfo> CreateESPSystemInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t heapSize = 0,
    int32_t model = 0,
    int32_t cores = 0,
    int32_t revision = 0,
    int32_t features = 0,
    const char *idf_version = nullptr) {
  return darknet7::CreateESPSystemInfo(
      _fbb,
      heapSize,
      model,
      cores,
      revision,
      features,
      idf_version ? _fbb.CreateString(idf_version) : 0);
}

struct ESPToSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MSGINSTANCEID = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  uint32_t msgInstanceID() const {
    return GetField<uint32_t>(VT_MSGINSTANCEID, 0);
  }
  ESPToSTMAny Msg_type() const {
    return static_cast<ESPToSTMAny>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *Msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *Msg_as() const;
  const GenericResponse *Msg_as_GenericResponse() const {
    return Msg_type() == ESPToSTMAny_GenericResponse ? static_cast<const GenericResponse *>(Msg()) : nullptr;
  }
  const ESPSystemInfo *Msg_as_ESPSystemInfo() const {
    return Msg_type() == ESPToSTMAny_ESPSystemInfo ? static_cast<const ESPSystemInfo *>(Msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MSGINSTANCEID) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyESPToSTMAny(verifier, Msg(), Msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GenericResponse *ESPToSTM::Msg_as<GenericResponse>() const {
  return Msg_as_GenericResponse();
}

template<> inline const ESPSystemInfo *ESPToSTM::Msg_as<ESPSystemInfo>() const {
  return Msg_as_ESPSystemInfo();
}

struct ESPToSTMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msgInstanceID(uint32_t msgInstanceID) {
    fbb_.AddElement<uint32_t>(ESPToSTM::VT_MSGINSTANCEID, msgInstanceID, 0);
  }
  void add_Msg_type(ESPToSTMAny Msg_type) {
    fbb_.AddElement<uint8_t>(ESPToSTM::VT_MSG_TYPE, static_cast<uint8_t>(Msg_type), 0);
  }
  void add_Msg(flatbuffers::Offset<void> Msg) {
    fbb_.AddOffset(ESPToSTM::VT_MSG, Msg);
  }
  explicit ESPToSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ESPToSTMBuilder &operator=(const ESPToSTMBuilder &);
  flatbuffers::Offset<ESPToSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ESPToSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<ESPToSTM> CreateESPToSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t msgInstanceID = 0,
    ESPToSTMAny Msg_type = ESPToSTMAny_NONE,
    flatbuffers::Offset<void> Msg = 0) {
  ESPToSTMBuilder builder_(_fbb);
  builder_.add_Msg(Msg);
  builder_.add_msgInstanceID(msgInstanceID);
  builder_.add_Msg_type(Msg_type);
  return builder_.Finish();
}

inline bool VerifyESPToSTMAny(flatbuffers::Verifier &verifier, const void *obj, ESPToSTMAny type) {
  switch (type) {
    case ESPToSTMAny_NONE: {
      return true;
    }
    case ESPToSTMAny_GenericResponse: {
      auto ptr = reinterpret_cast<const GenericResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ESPToSTMAny_ESPSystemInfo: {
      auto ptr = reinterpret_cast<const ESPSystemInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyESPToSTMAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyESPToSTMAny(
        verifier,  values->Get(i), types->GetEnum<ESPToSTMAny>(i))) {
      return false;
    }
  }
  return true;
}

inline const darknet7::ESPToSTM *GetESPToSTM(const void *buf) {
  return flatbuffers::GetRoot<darknet7::ESPToSTM>(buf);
}

inline const darknet7::ESPToSTM *GetSizePrefixedESPToSTM(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<darknet7::ESPToSTM>(buf);
}

inline bool VerifyESPToSTMBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<darknet7::ESPToSTM>(nullptr);
}

inline bool VerifySizePrefixedESPToSTMBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<darknet7::ESPToSTM>(nullptr);
}

inline void FinishESPToSTMBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darknet7::ESPToSTM> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedESPToSTMBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<darknet7::ESPToSTM> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace darknet7

#endif  // FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_
