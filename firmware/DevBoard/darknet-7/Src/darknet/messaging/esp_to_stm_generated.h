// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_
#define FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace darknet7 {

struct GenericResponse;

struct ESPToSTM;

enum RESPONSE_SUCCESS {
  RESPONSE_SUCCESS_False = 0,
  RESPONSE_SUCCESS_True = 1,
  RESPONSE_SUCCESS_MIN = RESPONSE_SUCCESS_False,
  RESPONSE_SUCCESS_MAX = RESPONSE_SUCCESS_True
};

inline const RESPONSE_SUCCESS (&EnumValuesRESPONSE_SUCCESS())[2] {
  static const RESPONSE_SUCCESS values[] = {
    RESPONSE_SUCCESS_False,
    RESPONSE_SUCCESS_True
  };
  return values;
}

inline const char * const *EnumNamesRESPONSE_SUCCESS() {
  static const char * const names[] = {
    "False",
    "True",
    nullptr
  };
  return names;
}

inline const char *EnumNameRESPONSE_SUCCESS(RESPONSE_SUCCESS e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRESPONSE_SUCCESS()[index];
}

enum ESPToSTMAny {
  ESPToSTMAny_NONE = 0,
  ESPToSTMAny_GenericResponse = 1,
  ESPToSTMAny_MIN = ESPToSTMAny_NONE,
  ESPToSTMAny_MAX = ESPToSTMAny_GenericResponse
};

inline const ESPToSTMAny (&EnumValuesESPToSTMAny())[2] {
  static const ESPToSTMAny values[] = {
    ESPToSTMAny_NONE,
    ESPToSTMAny_GenericResponse
  };
  return values;
}

inline const char * const *EnumNamesESPToSTMAny() {
  static const char * const names[] = {
    "NONE",
    "GenericResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameESPToSTMAny(ESPToSTMAny e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesESPToSTMAny()[index];
}

template<typename T> struct ESPToSTMAnyTraits {
  static const ESPToSTMAny enum_value = ESPToSTMAny_NONE;
};

template<> struct ESPToSTMAnyTraits<GenericResponse> {
  static const ESPToSTMAny enum_value = ESPToSTMAny_GenericResponse;
};

bool VerifyESPToSTMAny(flatbuffers::Verifier &verifier, const void *obj, ESPToSTMAny type);
bool VerifyESPToSTMAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct GenericResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESSFUL = 4,
    VT_MESSAGE = 6
  };
  RESPONSE_SUCCESS successful() const {
    return static_cast<RESPONSE_SUCCESS>(GetField<int8_t>(VT_SUCCESSFUL, 0));
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SUCCESSFUL) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
};

struct GenericResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_successful(RESPONSE_SUCCESS successful) {
    fbb_.AddElement<int8_t>(GenericResponse::VT_SUCCESSFUL, static_cast<int8_t>(successful), 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(GenericResponse::VT_MESSAGE, message);
  }
  explicit GenericResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GenericResponseBuilder &operator=(const GenericResponseBuilder &);
  flatbuffers::Offset<GenericResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GenericResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<GenericResponse> CreateGenericResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    RESPONSE_SUCCESS successful = RESPONSE_SUCCESS_False,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  GenericResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_successful(successful);
  return builder_.Finish();
}

inline flatbuffers::Offset<GenericResponse> CreateGenericResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    RESPONSE_SUCCESS successful = RESPONSE_SUCCESS_False,
    const char *message = nullptr) {
  return darknet7::CreateGenericResponse(
      _fbb,
      successful,
      message ? _fbb.CreateString(message) : 0);
}

struct ESPToSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MTYPE = 4,
    VT_MSG_TYPE = 6,
    VT_MSG = 8
  };
  MsgType MType() const {
    return static_cast<MsgType>(GetField<int8_t>(VT_MTYPE, 0));
  }
  ESPToSTMAny Msg_type() const {
    return static_cast<ESPToSTMAny>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *Msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *Msg_as() const;
  const GenericResponse *Msg_as_GenericResponse() const {
    return Msg_type() == ESPToSTMAny_GenericResponse ? static_cast<const GenericResponse *>(Msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MTYPE) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyESPToSTMAny(verifier, Msg(), Msg_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GenericResponse *ESPToSTM::Msg_as<GenericResponse>() const {
  return Msg_as_GenericResponse();
}

struct ESPToSTMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_MType(MsgType MType) {
    fbb_.AddElement<int8_t>(ESPToSTM::VT_MTYPE, static_cast<int8_t>(MType), 0);
  }
  void add_Msg_type(ESPToSTMAny Msg_type) {
    fbb_.AddElement<uint8_t>(ESPToSTM::VT_MSG_TYPE, static_cast<uint8_t>(Msg_type), 0);
  }
  void add_Msg(flatbuffers::Offset<void> Msg) {
    fbb_.AddOffset(ESPToSTM::VT_MSG, Msg);
  }
  explicit ESPToSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ESPToSTMBuilder &operator=(const ESPToSTMBuilder &);
  flatbuffers::Offset<ESPToSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ESPToSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<ESPToSTM> CreateESPToSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    MsgType MType = MsgType_RESERVED,
    ESPToSTMAny Msg_type = ESPToSTMAny_NONE,
    flatbuffers::Offset<void> Msg = 0) {
  ESPToSTMBuilder builder_(_fbb);
  builder_.add_Msg(Msg);
  builder_.add_Msg_type(Msg_type);
  builder_.add_MType(MType);
  return builder_.Finish();
}

inline bool VerifyESPToSTMAny(flatbuffers::Verifier &verifier, const void *obj, ESPToSTMAny type) {
  switch (type) {
    case ESPToSTMAny_NONE: {
      return true;
    }
    case ESPToSTMAny_GenericResponse: {
      auto ptr = reinterpret_cast<const GenericResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyESPToSTMAnyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyESPToSTMAny(
        verifier,  values->Get(i), types->GetEnum<ESPToSTMAny>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace darknet7

#endif  // FLATBUFFERS_GENERATED_ESPTOSTM_DARKNET7_H_
